pipeline {
    agent any
    
    // üéõÔ∏è PARAM√àTRES DU BUILD
    parameters {
        string(
            name: 'APP_PORT',
            defaultValue: '5000',
            description: 'Port de l\'application backend'
        )
        choice(
            name: 'ENVIRONMENT',
            choices: ['development', 'testing', 'staging', 'production'],
            description: 'Environnement de d√©ploiement'
        )
        string(
            name: 'APP_VERSION_SUFFIX',
            defaultValue: '',
            description: 'Suffixe de version (ex: -beta, -rc1)'
        )
        string(
            name: 'DOCKER_REGISTRY',
            defaultValue: 'localhost:5000',
            description: 'Registry Docker (optionnel)'
        )
        booleanParam(
            name: 'PUSH_TO_REGISTRY',
            defaultValue: false,
            description: 'Pousser les images vers le registry'
        )
    }
    
    // üåç VARIABLES D'ENVIRONNEMENT
    environment {
        PYTHONPATH = "${WORKSPACE}/backend"
        BUILD_VERSION = "1.0.${env.BUILD_NUMBER}${params.APP_VERSION_SUFFIX}"
        
        // Variables Docker
        DOCKER_IMAGE_PREFIX = "projet"
        FRONTEND_IMAGE = "${env.DOCKER_IMAGE_PREFIX}-front"
        BACKEND_IMAGE = "${env.DOCKER_IMAGE_PREFIX}-back"
        
        // Tags des images
        IMAGE_TAG = "${env.BUILD_VERSION}-${params.ENVIRONMENT}"
        LATEST_TAG = "${params.ENVIRONMENT}"
        
        // Variables configurables
        APP_PORT = "${params.APP_PORT}"
        DEPLOY_ENV = "${params.ENVIRONMENT}"
        DOCKER_REGISTRY = "${params.DOCKER_REGISTRY}"
    }
    
    stages {
        stage('üîç Checkout & Docker Info') {
            steps {
                echo "üê≥ Pipeline Docker ${env.BUILD_VERSION} - Env: ${env.DEPLOY_ENV}"
                sh '''
                    echo "======================================"
                    echo "üê≥ INFORMATIONS DOCKER BUILD"
                    echo "======================================"
                    echo "üì¶ Version: ${BUILD_VERSION}"
                    echo "üåç Environnement: ${DEPLOY_ENV}"
                    echo "üîå Port Backend: ${APP_PORT}"
                    echo "üè∑Ô∏è Tag Images: ${IMAGE_TAG}"
                    echo "üìÅ Image Frontend: ${FRONTEND_IMAGE}:${IMAGE_TAG}"
                    echo "‚öôÔ∏è Image Backend: ${BACKEND_IMAGE}:${IMAGE_TAG}"
                    echo "üè† Registry: ${DOCKER_REGISTRY}"
                    echo "‚òÅÔ∏è Push Registry: ${PUSH_TO_REGISTRY}"
                    echo "======================================"
                    
                    # V√©rification Docker
                    docker --version
                    docker info | head -10
                    
                    # Nettoyage images anciennes (optionnel)
                    docker image prune -f || true
                '''
            }
        }
        
        stage('üîß Setup Environment') {
            agent {
                docker {
                    image 'python:3.11-slim'
                    args '-u root'
                }
            }
            steps {
                sh '''
                    pip install --upgrade pip
                    apt-get update && apt-get install -y zip unzip jq
                    pip install flask flask-cors requests pytest pytest-html pytest-cov
                '''
            }
        }
        
        stage('üß™ Run Tests') {
            agent {
                docker {
                    image 'python:3.11-slim'
                    args '-u root'
                }
            }
            steps {
                sh '''
                    pip install flask flask-cors requests pytest pytest-html pytest-cov
                    export PYTHONPATH="${WORKSPACE}/backend"
                    pytest -v --junitxml=test-results.xml --html=test-report.html backend/
                '''
            }
            post {
                always {
                    junit 'test-results.xml'
                    archiveArtifacts 'test-report.html'
                }
            }
        }
        
        stage('‚öôÔ∏è Generate Docker Configurations') {
            when {
                expression { currentBuild.result != 'FAILURE' }
            }
            steps {
                echo 'üìù G√©n√©ration des configurations et Dockerfiles'
                sh '''
                    # Cr√©ation des r√©pertoires
                    mkdir -p docker-build/frontend docker-build/backend
                    
                    echo "üìù G√©n√©ration configuration application"
                    # Configuration JSON
                    cat > app_config.json << EOF
{
    "application": {
        "name": "CICD-DOCKER-${DEPLOY_ENV}",
        "version": "${BUILD_VERSION}",
        "environment": "${DEPLOY_ENV}",
        "debug": $([ "${DEPLOY_ENV}" = "development" ] && echo "true" || echo "false")
    },
    "server": {
        "host": "0.0.0.0",
        "port": ${APP_PORT},
        "threaded": true
    },
    "docker": {
        "frontend_image": "${FRONTEND_IMAGE}:${IMAGE_TAG}",
        "backend_image": "${BACKEND_IMAGE}:${IMAGE_TAG}",
        "build_date": "$(date -Iseconds)"
    }
}
EOF
                    
                    echo "‚úÖ Configuration g√©n√©r√©e"
                    cat app_config.json
                '''
            }
        }
        
        stage('üé® Build Frontend Docker Image') {
            when {
                expression { currentBuild.result != 'FAILURE' }
            }
            steps {
                echo 'üé® Construction de l\'image Docker Frontend'
                sh '''
                    cd docker-build/frontend
                    
                    echo "üìÅ Pr√©paration des fichiers frontend"
                    # Copie des fichiers frontend ou g√©n√©ration
                    if [ -d "../../frontend" ]; then
                        cp -r ../../frontend/* .
                    else
                        # G√©n√©ration d'un frontend avec info Docker
                        cat > index.html << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>CICD Docker Frontend</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .container { 
            background: white;
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 500px;
            margin: 20px;
        }
        h1 { color: #333; margin-bottom: 1rem; }
        .docker-info { 
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            text-align: left;
        }
        .api-links a {
            display: inline-block;
            margin: 10px;
            padding: 10px 20px;
            background: #007bff;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            transition: background 0.3s;
        }
        .api-links a:hover { background: #0056b3; }
        .version { color: #666; font-size: 0.9em; margin-top: 1rem; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üê≥ CICD Docker Frontend</h1>
        <p>Application conteneuris√©e avec Jenkins</p>
        
        <div class="docker-info">
            <h3>üì¶ Informations Container</h3>
            <p><strong>Version:</strong> ${BUILD_VERSION}</p>
            <p><strong>Environnement:</strong> ${DEPLOY_ENV}</p>
            <p><strong>Image:</strong> ${FRONTEND_IMAGE}:${IMAGE_TAG}</p>
            <p><strong>Build:</strong> #${BUILD_NUMBER}</p>
        </div>
        
        <div class="api-links">
            <a href="http://localhost:${APP_PORT}/" target="_blank">üîó API Backend</a>
            <a href="http://localhost:${APP_PORT}/health" target="_blank">üè• Health Check</a>
            <a href="http://localhost:${APP_PORT}/config" target="_blank">‚öôÔ∏è Configuration</a>
        </div>
        
        <div class="version">
            D√©ploy√© avec Jenkins le $(date)
        </div>
    </div>
    
    <script>
        console.log('üê≥ Frontend Docker d√©marr√©');
        console.log('Version: ${BUILD_VERSION}');
        console.log('Environnement: ${DEPLOY_ENV}');
        
        // Test de l'API Backend
        fetch('http://localhost:${APP_PORT}/health')
            .then(response => response.json())
            .then(data => console.log('‚úÖ Backend connect√©:', data))
            .catch(error => console.log('‚ö†Ô∏è Backend non accessible:', error));
    </script>
</body>
</html>
EOF
                    fi
                    
                    echo "üê≥ Cr√©ation du Dockerfile Frontend"
                    cat > Dockerfile << 'EOF'
# Image Nginx pour servir le frontend
FROM nginx:alpine

# M√©tadonn√©es
LABEL maintainer="Jenkins CI/CD"
LABEL version="${BUILD_VERSION}"
LABEL environment="${DEPLOY_ENV}"

# Copie des fichiers frontend
COPY . /usr/share/nginx/html/

# Configuration Nginx personnalis√©e
RUN echo 'server {' > /etc/nginx/conf.d/default.conf && \\
    echo '    listen 80;' >> /etc/nginx/conf.d/default.conf && \\
    echo '    server_name localhost;' >> /etc/nginx/conf.d/default.conf && \\
    echo '    root /usr/share/nginx/html;' >> /etc/nginx/conf.d/default.conf && \\
    echo '    index index.html;' >> /etc/nginx/conf.d/default.conf && \\
    echo '    try_files $$uri $$uri/ /index.html;' >> /etc/nginx/conf.d/default.conf && \\
    echo '}' >> /etc/nginx/conf.d/default.conf

# Port expos√©
EXPOSE 80

# Commande de d√©marrage
CMD ["nginx", "-g", "daemon off;"]
EOF
                    
                    echo "üèóÔ∏è Build de l'image Frontend"
                    docker build -t ${FRONTEND_IMAGE}:${IMAGE_TAG} .
                    docker tag ${FRONTEND_IMAGE}:${IMAGE_TAG} ${FRONTEND_IMAGE}:${LATEST_TAG}
                    docker tag ${FRONTEND_IMAGE}:${IMAGE_TAG} ${FRONTEND_IMAGE}:latest
                    
                    echo "‚úÖ Image Frontend cr√©√©e: ${FRONTEND_IMAGE}:${IMAGE_TAG}"
                    docker images | grep ${FRONTEND_IMAGE}
                '''
            }
        }
        
        stage('‚öôÔ∏è Build Backend Docker Image') {
            when {
                expression { currentBuild.result != 'FAILURE' }
            }
            steps {
                echo '‚öôÔ∏è Construction de l\'image Docker Backend'
                sh '''
                    cd docker-build/backend
                    
                    echo "üìÅ Pr√©paration des fichiers backend"
                    # Copie des fichiers backend
                    cp -r ../../backend/* .
                    cp ../../app_config.json .
                    
                    # Requirements pour Docker
                    cat > requirements.txt << EOF
flask==$([ "${DEPLOY_ENV}" = "production" ] && echo "3.1.2" || echo "3.1.2")
flask-cors==$([ "${DEPLOY_ENV}" = "production" ] && echo "4.0.0" || echo "4.0.0")
requests==$([ "${DEPLOY_ENV}" = "production" ] && echo "2.31.0" || echo "2.31.0")
gunicorn==21.2.0
EOF
                    
                    # Application Docker avec configuration
                    cat > app_docker.py << 'EOF'
#!/usr/bin/env python3
import json
import os
import sys
from flask import Flask, jsonify
from flask_cors import CORS

def load_config():
    """Charge la configuration depuis le fichier JSON"""
    if os.path.exists('app_config.json'):
        with open('app_config.json', 'r') as f:
            return json.load(f)
    return {
        "application": {"name": "CICD-DOCKER", "version": "1.0.0", "environment": "development"},
        "server": {"host": "0.0.0.0", "port": 5000}
    }

config = load_config()
app = Flask(__name__)

# Configuration CORS pour Docker
CORS(app, resources={
    r"/*": {
        "origins": "*",
        "methods": ["GET", "POST", "PUT", "DELETE"],
        "allow_headers": "*"
    }
})

# Import des routes existantes si disponibles
try:
    from app import *
except ImportError:
    print("‚ö†Ô∏è Routes personnalis√©es non trouv√©es, utilisation des routes par d√©faut")

# Routes sp√©cifiques Docker
@app.route('/')
def docker_home():
    return jsonify({
        "message": "üê≥ Backend Docker CICD",
        "version": config["application"]["version"],
        "environment": config["application"]["environment"],
        "container": "Docker Backend",
        "endpoints": ["/health", "/config", "/docker-info"]
    })

@app.route('/health')
def health_check():
    return jsonify({
        "status": "healthy",
        "application": config["application"]["name"],
        "version": config["application"]["version"],
        "environment": config["application"]["environment"],
        "docker": True,
        "timestamp": "$(date -Iseconds)"
    })

@app.route('/config')
def get_config():
    return jsonify(config)

@app.route('/docker-info')
def docker_info():
    return jsonify({
        "container_info": {
            "image": "${BACKEND_IMAGE}:${IMAGE_TAG}",
            "port": config["server"]["port"],
            "environment": config["application"]["environment"],
            "python_version": sys.version,
            "flask_mode": "Docker Production" if config["application"]["environment"] == "production" else "Docker Development"
        }
    })

if __name__ == '__main__':
    print(f"üê≥ D√©marrage Backend Docker {config['application']['name']}")
    print(f"üåç Environnement: {config['application']['environment']}")
    print(f"üîå Port: {config['server']['port']}")
    
    # D√©marrage selon l'environnement
    if config["application"]["environment"] == "production":
        # En production, on utiliserait Gunicorn
        print("üöÄ Mode Production avec Gunicorn")
        import subprocess
        subprocess.run([
            "gunicorn", 
            "--bind", f"0.0.0.0:{config['server']['port']}", 
            "--workers", "3",
            "app_docker:app"
        ])
    else:
        print("üîß Mode Development avec Flask dev server")
        app.run(
            host=config['server']['host'],
            port=int(config['server']['port']),
            debug=config['application'].get('debug', False)
        )
EOF
                    
                    echo "üê≥ Cr√©ation du Dockerfile Backend"
                    cat > Dockerfile << 'EOF'
# Image Python officielle
FROM python:3.11-slim

# M√©tadonn√©es
LABEL maintainer="Jenkins CI/CD"
LABEL version="${BUILD_VERSION}"
LABEL environment="${DEPLOY_ENV}"

# R√©pertoire de travail
WORKDIR /app

# Installation des d√©pendances syst√®me
RUN apt-get update && apt-get install -y \\
    curl \\
    && rm -rf /var/lib/apt/lists/*

# Copie et installation des requirements
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copie du code application
COPY . .

# Cr√©ation d'un utilisateur non-root
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

# Port expos√©
EXPOSE ${APP_PORT}

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
    CMD curl -f http://localhost:${APP_PORT}/health || exit 1

# Point d'entr√©e
ENTRYPOINT ["python3", "app_docker.py"]
EOF
                    
                    echo "üèóÔ∏è Build de l'image Backend"
                    docker build -t ${BACKEND_IMAGE}:${IMAGE_TAG} .
                    docker tag ${BACKEND_IMAGE}:${IMAGE_TAG} ${BACKEND_IMAGE}:${LATEST_TAG}
                    docker tag ${BACKEND_IMAGE}:${IMAGE_TAG} ${BACKEND_IMAGE}:latest
                    
                    echo "‚úÖ Image Backend cr√©√©e: ${BACKEND_IMAGE}:${IMAGE_TAG}"
                    docker images | grep ${BACKEND_IMAGE}
                '''
            }
        }
        
        stage('üîç Docker Images Verification') {
            steps {
                echo 'üîç V√©rification des images Docker cr√©√©es'
                sh '''
                    echo "======================================"
                    echo "üê≥ IMAGES DOCKER CR√â√âES"
                    echo "======================================"
                    
                    echo "üìä Liste des images:"
                    docker images | grep -E "(${FRONTEND_IMAGE}|${BACKEND_IMAGE})" || echo "Aucune image trouv√©e"
                    
                    echo ""
                    echo "üè∑Ô∏è Tags cr√©√©s:"
                    echo "Frontend:"
                    docker images ${FRONTEND_IMAGE} --format "table {{.Repository}}:{{.Tag}}\\t{{.Size}}\\t{{.CreatedSince}}"
                    echo "Backend:"
                    docker images ${BACKEND_IMAGE} --format "table {{.Repository}}:{{.Tag}}\\t{{.Size}}\\t{{.CreatedSince}}"
                    
                    echo ""
                    echo "üîç Test rapide des images:"
                    echo "Frontend image info:"
                    docker inspect ${FRONTEND_IMAGE}:${IMAGE_TAG} --format='{{.Config.Labels}}'
                    echo "Backend image info:"
                    docker inspect ${BACKEND_IMAGE}:${IMAGE_TAG} --format='{{.Config.Labels}}'
                    
                    # Calcul de l'espace utilis√©
                    FRONTEND_SIZE=$(docker images ${FRONTEND_IMAGE}:${IMAGE_TAG} --format "{{.Size}}")
                    BACKEND_SIZE=$(docker images ${BACKEND_IMAGE}:${IMAGE_TAG} --format "{{.Size}}")
                    echo ""
                    echo "üíæ Tailles des images:"
                    echo "Frontend: $FRONTEND_SIZE"
                    echo "Backend: $BACKEND_SIZE"
                '''
            }
        }
        
        stage('üß™ Test Docker Images') {
            steps {
                echo 'üß™ Test rapide des images Docker'
                sh '''
                    echo "üî¨ Test du backend Docker (d√©marrage rapide)"
                    
                    # Test de d√©marrage du backend
                    echo "D√©marrage temporaire du backend..."
                    CONTAINER_ID=$(docker run -d -p ${APP_PORT}:${APP_PORT} ${BACKEND_IMAGE}:${IMAGE_TAG})
                    
                    echo "Attente d√©marrage..."
                    sleep 10
                    
                    # Test des endpoints
                    echo "Test health check:"
                    curl -f http://localhost:${APP_PORT}/health || echo "Health check non disponible"
                    
                    echo "Test endpoint racine:"
                    curl -f http://localhost:${APP_PORT}/ || echo "Endpoint racine non disponible"
                    
                    # Nettoyage
                    echo "Arr√™t du container de test..."
                    docker stop $CONTAINER_ID
                    docker rm $CONTAINER_ID
                    
                    echo "‚úÖ Test des images termin√©"
                '''
            }
        }
        
        stage('‚òÅÔ∏è Push to Registry (Optional)') {
            when {
                expression { params.PUSH_TO_REGISTRY }
            }
            steps {
                echo "‚òÅÔ∏è Push des images vers le registry ${env.DOCKER_REGISTRY}"
                sh '''
                    if [ "${DOCKER_REGISTRY}" != "localhost:5000" ]; then
                        echo "üîê Connexion au registry ${DOCKER_REGISTRY}"
                        # docker login ${DOCKER_REGISTRY} # N√©cessiterait les credentials
                    fi
                    
                    echo "üì§ Tag pour registry"
                    docker tag ${FRONTEND_IMAGE}:${IMAGE_TAG} ${DOCKER_REGISTRY}/${FRONTEND_IMAGE}:${IMAGE_TAG}
                    docker tag ${BACKEND_IMAGE}:${IMAGE_TAG} ${DOCKER_REGISTRY}/${BACKEND_IMAGE}:${IMAGE_TAG}
                    
                    echo "üöÄ Push des images"
                    # docker push ${DOCKER_REGISTRY}/${FRONTEND_IMAGE}:${IMAGE_TAG}
                    # docker push ${DOCKER_REGISTRY}/${BACKEND_IMAGE}:${IMAGE_TAG}
                    
                    echo "‚ö†Ô∏è Push d√©sactiv√© pour la d√©mo (pas de registry configur√©)"
                    echo "Images tagu√©es pour push:"
                    docker images | grep ${DOCKER_REGISTRY}
                '''
            }
        }
        
        stage('üìã Docker Summary') {
            steps {
                sh '''
                    echo "üéØ R√âSUM√â DOCKER BUILD"
                    echo "====================="
                    echo "üì¶ Version: ${BUILD_VERSION}"
                    echo "üåç Environnement: ${DEPLOY_ENV}"
                    echo "üè∑Ô∏è Tag: ${IMAGE_TAG}"
                    echo ""
                    echo "üñºÔ∏è Images cr√©√©es:"
                    echo "  Frontend: ${FRONTEND_IMAGE}:${IMAGE_TAG}"
                    echo "  Backend:  ${BACKEND_IMAGE}:${IMAGE_TAG}"
                    echo ""
                    echo "üöÄ Commandes de d√©ploiement:"
                    echo "# Frontend:"
                    echo "docker run -d -p 80:80 --name frontend-${DEPLOY_ENV} ${FRONTEND_IMAGE}:${IMAGE_TAG}"
                    echo ""
                    echo "# Backend:"
                    echo "docker run -d -p ${APP_PORT}:${APP_PORT} --name backend-${DEPLOY_ENV} ${BACKEND_IMAGE}:${IMAGE_TAG}"
                    echo ""
                    echo "# Docker Compose exemple:"
                    echo "version: '3.8'"
                    echo "services:"
                    echo "  frontend:"
                    echo "    image: ${FRONTEND_IMAGE}:${IMAGE_TAG}"
                    echo "    ports: ['80:80']"
                    echo "  backend:"
                    echo "    image: ${BACKEND_IMAGE}:${IMAGE_TAG}"
                    echo "    ports: ['${APP_PORT}:${APP_PORT}']"
                    
                    # Sauvegarde des informations Docker
                    cat > docker-summary.json << EOF
{
    "docker_build": {
        "version": "${BUILD_VERSION}",
        "environment": "${DEPLOY_ENV}",
        "images": {
            "frontend": {
                "name": "${FRONTEND_IMAGE}",
                "tag": "${IMAGE_TAG}",
                "full_name": "${FRONTEND_IMAGE}:${IMAGE_TAG}",
                "port": 80
            },
            "backend": {
                "name": "${BACKEND_IMAGE}",
                "tag": "${IMAGE_TAG}",
                "full_name": "${BACKEND_IMAGE}:${IMAGE_TAG}",
                "port": ${APP_PORT}
            }
        },
        "build_date": "$(date -Iseconds)",
        "jenkins_build": "${BUILD_NUMBER}"
    }
}
EOF
                '''
            }
        }
    }
    
    post {
        always {
            script {
                archiveArtifacts artifacts: 'docker-summary.json, docker-build/**/*', 
                               fingerprint: true, 
                               allowEmptyArchive: true
            }
        }
        
        success {
            echo 'üéâ BUILD DOCKER R√âUSSI!'
            echo "‚úÖ Images cr√©√©es:"
            echo "   üé® Frontend: ${env.FRONTEND_IMAGE}:${env.IMAGE_TAG}"
            echo "   ‚öôÔ∏è Backend:  ${env.BACKEND_IMAGE}:${env.IMAGE_TAG}"
        }
        
        failure {
            echo '‚ùå BUILD DOCKER √âCHOU√â!'
        }
        
        cleanup {
            // Nettoyage optionnel des images de d√©veloppement
            sh '''
                if [ "${DEPLOY_ENV}" = "development" ]; then
                    echo "üßπ Nettoyage des images de d√©veloppement anciennes"
                    docker image prune -f || true
                fi
            '''
        }
    }
}
